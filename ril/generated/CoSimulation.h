/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CoSimulation_H
#define CoSimulation_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "ril_types.h"

namespace org { namespace raspinloop { namespace fmi {

#ifdef _WIN32
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class CoSimulationIf {
 public:
  virtual ~CoSimulationIf() {}
  virtual void getVersion(std::string& _return) = 0;
  virtual void getTypesPlatform(std::string& _return) = 0;
  virtual void instanciate(Instance& _return, const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn) = 0;
  virtual Status::type setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime) = 0;
  virtual Status::type enterInitializationMode(const Instance& c) = 0;
  virtual Status::type exitInitializationMode(const Instance& c) = 0;
  virtual Status::type terminate(const Instance& c) = 0;
  virtual Status::type reset(const Instance& c) = 0;
  virtual void freeInstance(const Instance& c) = 0;
  virtual void getReal(std::vector<double> & _return, const Instance& c, const std::vector<int32_t> & refs) = 0;
  virtual void getInteger(std::vector<int32_t> & _return, const Instance& c, const std::vector<int32_t> & refs) = 0;
  virtual void getBoolean(std::vector<bool> & _return, const Instance& c, const std::vector<int32_t> & refs) = 0;
  virtual void getString(std::vector<std::string> & _return, const Instance& c, const std::vector<int32_t> & refs) = 0;
  virtual Status::type setReal(const Instance& c, const std::map<int32_t, double> & ref_values) = 0;
  virtual Status::type setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values) = 0;
  virtual Status::type setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values) = 0;
  virtual Status::type setString(const Instance& c, const std::map<int32_t, std::string> & ref_values) = 0;
  virtual Status::type setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values) = 0;
  virtual Status::type setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values) = 0;
  virtual Status::type cancelStep(const Instance& c) = 0;
  virtual Status::type doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint) = 0;
  virtual Status::type getStatus(const Instance& c, const StatusKind::type s) = 0;
  virtual int32_t getIntegerStatus(const Instance& c, const StatusKind::type s) = 0;
  virtual double getRealStatus(const Instance& c, const StatusKind::type s) = 0;
  virtual bool getBooleanStatus(const Instance& c, const StatusKind::type s) = 0;
  virtual void getStringStatus(std::string& _return, const Instance& c, const StatusKind::type s) = 0;
};

class CoSimulationIfFactory {
 public:
  typedef CoSimulationIf Handler;

  virtual ~CoSimulationIfFactory() {}

  virtual CoSimulationIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(CoSimulationIf* /* handler */) = 0;
};

class CoSimulationIfSingletonFactory : virtual public CoSimulationIfFactory {
 public:
  CoSimulationIfSingletonFactory(const boost::shared_ptr<CoSimulationIf>& iface) : iface_(iface) {}
  virtual ~CoSimulationIfSingletonFactory() {}

  virtual CoSimulationIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(CoSimulationIf* /* handler */) {}

 protected:
  boost::shared_ptr<CoSimulationIf> iface_;
};

class CoSimulationNull : virtual public CoSimulationIf {
 public:
  virtual ~CoSimulationNull() {}
  void getVersion(std::string& /* _return */) {
    return;
  }
  void getTypesPlatform(std::string& /* _return */) {
    return;
  }
  void instanciate(Instance& /* _return */, const std::string& /* instanceName */, const Type::type /* fmuType */, const std::string& /* fmuGUID */, const std::string& /* fmuResourceLocation */, const bool /* visible */, const bool /* loggingOn */) {
    return;
  }
  Status::type setupExperiment(const Instance& /* c */, const bool /* toleranceDefined */, const double /* tolerance */, const double /* startTime */, const bool /* stopTimeDefined */, const double /* stopTime */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type enterInitializationMode(const Instance& /* c */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type exitInitializationMode(const Instance& /* c */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type terminate(const Instance& /* c */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type reset(const Instance& /* c */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  void freeInstance(const Instance& /* c */) {
    return;
  }
  void getReal(std::vector<double> & /* _return */, const Instance& /* c */, const std::vector<int32_t> & /* refs */) {
    return;
  }
  void getInteger(std::vector<int32_t> & /* _return */, const Instance& /* c */, const std::vector<int32_t> & /* refs */) {
    return;
  }
  void getBoolean(std::vector<bool> & /* _return */, const Instance& /* c */, const std::vector<int32_t> & /* refs */) {
    return;
  }
  void getString(std::vector<std::string> & /* _return */, const Instance& /* c */, const std::vector<int32_t> & /* refs */) {
    return;
  }
  Status::type setReal(const Instance& /* c */, const std::map<int32_t, double> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type setInteger(const Instance& /* c */, const std::map<int32_t, int32_t> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type setBoolean(const Instance& /* c */, const std::map<int32_t, bool> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type setString(const Instance& /* c */, const std::map<int32_t, std::string> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type setRealInputDerivatives(const Instance& /* c */, const std::map<int32_t, int32_t> & /* ref_orders */, const std::map<int32_t, double> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type setRealOutputDerivatives(const Instance& /* c */, const std::map<int32_t, int32_t> & /* ref_orders */, const std::map<int32_t, double> & /* ref_values */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type cancelStep(const Instance& /* c */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type doStep(const Instance& /* c */, const double /* currentCommunicationPoint */, const double /* communicationStepSize */, const bool /* noSetFMUStatePriorToCurrentPoint */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  Status::type getStatus(const Instance& /* c */, const StatusKind::type /* s */) {
    Status::type _return = (Status::type)0;
    return _return;
  }
  int32_t getIntegerStatus(const Instance& /* c */, const StatusKind::type /* s */) {
    int32_t _return = 0;
    return _return;
  }
  double getRealStatus(const Instance& /* c */, const StatusKind::type /* s */) {
    double _return = (double)0;
    return _return;
  }
  bool getBooleanStatus(const Instance& /* c */, const StatusKind::type /* s */) {
    bool _return = false;
    return _return;
  }
  void getStringStatus(std::string& /* _return */, const Instance& /* c */, const StatusKind::type /* s */) {
    return;
  }
};


class CoSimulation_getVersion_args {
 public:

  CoSimulation_getVersion_args(const CoSimulation_getVersion_args&);
  CoSimulation_getVersion_args& operator=(const CoSimulation_getVersion_args&);
  CoSimulation_getVersion_args() {
  }

  virtual ~CoSimulation_getVersion_args() throw();

  bool operator == (const CoSimulation_getVersion_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CoSimulation_getVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getVersion_pargs {
 public:


  virtual ~CoSimulation_getVersion_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getVersion_result__isset {
  _CoSimulation_getVersion_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getVersion_result__isset;

class CoSimulation_getVersion_result {
 public:

  CoSimulation_getVersion_result(const CoSimulation_getVersion_result&);
  CoSimulation_getVersion_result& operator=(const CoSimulation_getVersion_result&);
  CoSimulation_getVersion_result() : success() {
  }

  virtual ~CoSimulation_getVersion_result() throw();
  std::string success;

  _CoSimulation_getVersion_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const CoSimulation_getVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getVersion_presult__isset {
  _CoSimulation_getVersion_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getVersion_presult__isset;

class CoSimulation_getVersion_presult {
 public:


  virtual ~CoSimulation_getVersion_presult() throw();
  std::string* success;

  _CoSimulation_getVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class CoSimulation_getTypesPlatform_args {
 public:

  CoSimulation_getTypesPlatform_args(const CoSimulation_getTypesPlatform_args&);
  CoSimulation_getTypesPlatform_args& operator=(const CoSimulation_getTypesPlatform_args&);
  CoSimulation_getTypesPlatform_args() {
  }

  virtual ~CoSimulation_getTypesPlatform_args() throw();

  bool operator == (const CoSimulation_getTypesPlatform_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CoSimulation_getTypesPlatform_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getTypesPlatform_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getTypesPlatform_pargs {
 public:


  virtual ~CoSimulation_getTypesPlatform_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getTypesPlatform_result__isset {
  _CoSimulation_getTypesPlatform_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getTypesPlatform_result__isset;

class CoSimulation_getTypesPlatform_result {
 public:

  CoSimulation_getTypesPlatform_result(const CoSimulation_getTypesPlatform_result&);
  CoSimulation_getTypesPlatform_result& operator=(const CoSimulation_getTypesPlatform_result&);
  CoSimulation_getTypesPlatform_result() : success() {
  }

  virtual ~CoSimulation_getTypesPlatform_result() throw();
  std::string success;

  _CoSimulation_getTypesPlatform_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const CoSimulation_getTypesPlatform_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getTypesPlatform_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getTypesPlatform_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getTypesPlatform_presult__isset {
  _CoSimulation_getTypesPlatform_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getTypesPlatform_presult__isset;

class CoSimulation_getTypesPlatform_presult {
 public:


  virtual ~CoSimulation_getTypesPlatform_presult() throw();
  std::string* success;

  _CoSimulation_getTypesPlatform_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_instanciate_args__isset {
  _CoSimulation_instanciate_args__isset() : instanceName(false), fmuType(false), fmuGUID(false), fmuResourceLocation(false), visible(false), loggingOn(false) {}
  bool instanceName :1;
  bool fmuType :1;
  bool fmuGUID :1;
  bool fmuResourceLocation :1;
  bool visible :1;
  bool loggingOn :1;
} _CoSimulation_instanciate_args__isset;

class CoSimulation_instanciate_args {
 public:

  CoSimulation_instanciate_args(const CoSimulation_instanciate_args&);
  CoSimulation_instanciate_args& operator=(const CoSimulation_instanciate_args&);
  CoSimulation_instanciate_args() : instanceName(), fmuType((Type::type)0), fmuGUID(), fmuResourceLocation(), visible(0), loggingOn(0) {
  }

  virtual ~CoSimulation_instanciate_args() throw();
  std::string instanceName;
  Type::type fmuType;
  std::string fmuGUID;
  std::string fmuResourceLocation;
  bool visible;
  bool loggingOn;

  _CoSimulation_instanciate_args__isset __isset;

  void __set_instanceName(const std::string& val);

  void __set_fmuType(const Type::type val);

  void __set_fmuGUID(const std::string& val);

  void __set_fmuResourceLocation(const std::string& val);

  void __set_visible(const bool val);

  void __set_loggingOn(const bool val);

  bool operator == (const CoSimulation_instanciate_args & rhs) const
  {
    if (!(instanceName == rhs.instanceName))
      return false;
    if (!(fmuType == rhs.fmuType))
      return false;
    if (!(fmuGUID == rhs.fmuGUID))
      return false;
    if (!(fmuResourceLocation == rhs.fmuResourceLocation))
      return false;
    if (!(visible == rhs.visible))
      return false;
    if (!(loggingOn == rhs.loggingOn))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_instanciate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_instanciate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_instanciate_pargs {
 public:


  virtual ~CoSimulation_instanciate_pargs() throw();
  const std::string* instanceName;
  const Type::type* fmuType;
  const std::string* fmuGUID;
  const std::string* fmuResourceLocation;
  const bool* visible;
  const bool* loggingOn;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_instanciate_result__isset {
  _CoSimulation_instanciate_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_instanciate_result__isset;

class CoSimulation_instanciate_result {
 public:

  CoSimulation_instanciate_result(const CoSimulation_instanciate_result&);
  CoSimulation_instanciate_result& operator=(const CoSimulation_instanciate_result&);
  CoSimulation_instanciate_result() {
  }

  virtual ~CoSimulation_instanciate_result() throw();
  Instance success;

  _CoSimulation_instanciate_result__isset __isset;

  void __set_success(const Instance& val);

  bool operator == (const CoSimulation_instanciate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_instanciate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_instanciate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_instanciate_presult__isset {
  _CoSimulation_instanciate_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_instanciate_presult__isset;

class CoSimulation_instanciate_presult {
 public:


  virtual ~CoSimulation_instanciate_presult() throw();
  Instance* success;

  _CoSimulation_instanciate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setupExperiment_args__isset {
  _CoSimulation_setupExperiment_args__isset() : c(false), toleranceDefined(false), tolerance(false), startTime(false), stopTimeDefined(false), stopTime(false) {}
  bool c :1;
  bool toleranceDefined :1;
  bool tolerance :1;
  bool startTime :1;
  bool stopTimeDefined :1;
  bool stopTime :1;
} _CoSimulation_setupExperiment_args__isset;

class CoSimulation_setupExperiment_args {
 public:

  CoSimulation_setupExperiment_args(const CoSimulation_setupExperiment_args&);
  CoSimulation_setupExperiment_args& operator=(const CoSimulation_setupExperiment_args&);
  CoSimulation_setupExperiment_args() : toleranceDefined(0), tolerance(0), startTime(0), stopTimeDefined(0), stopTime(0) {
  }

  virtual ~CoSimulation_setupExperiment_args() throw();
  Instance c;
  bool toleranceDefined;
  double tolerance;
  double startTime;
  bool stopTimeDefined;
  double stopTime;

  _CoSimulation_setupExperiment_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_toleranceDefined(const bool val);

  void __set_tolerance(const double val);

  void __set_startTime(const double val);

  void __set_stopTimeDefined(const bool val);

  void __set_stopTime(const double val);

  bool operator == (const CoSimulation_setupExperiment_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(toleranceDefined == rhs.toleranceDefined))
      return false;
    if (!(tolerance == rhs.tolerance))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTimeDefined == rhs.stopTimeDefined))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setupExperiment_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setupExperiment_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setupExperiment_pargs {
 public:


  virtual ~CoSimulation_setupExperiment_pargs() throw();
  const Instance* c;
  const bool* toleranceDefined;
  const double* tolerance;
  const double* startTime;
  const bool* stopTimeDefined;
  const double* stopTime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setupExperiment_result__isset {
  _CoSimulation_setupExperiment_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setupExperiment_result__isset;

class CoSimulation_setupExperiment_result {
 public:

  CoSimulation_setupExperiment_result(const CoSimulation_setupExperiment_result&);
  CoSimulation_setupExperiment_result& operator=(const CoSimulation_setupExperiment_result&);
  CoSimulation_setupExperiment_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setupExperiment_result() throw();
  Status::type success;

  _CoSimulation_setupExperiment_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setupExperiment_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setupExperiment_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setupExperiment_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setupExperiment_presult__isset {
  _CoSimulation_setupExperiment_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setupExperiment_presult__isset;

class CoSimulation_setupExperiment_presult {
 public:


  virtual ~CoSimulation_setupExperiment_presult() throw();
  Status::type* success;

  _CoSimulation_setupExperiment_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_enterInitializationMode_args__isset {
  _CoSimulation_enterInitializationMode_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_enterInitializationMode_args__isset;

class CoSimulation_enterInitializationMode_args {
 public:

  CoSimulation_enterInitializationMode_args(const CoSimulation_enterInitializationMode_args&);
  CoSimulation_enterInitializationMode_args& operator=(const CoSimulation_enterInitializationMode_args&);
  CoSimulation_enterInitializationMode_args() {
  }

  virtual ~CoSimulation_enterInitializationMode_args() throw();
  Instance c;

  _CoSimulation_enterInitializationMode_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_enterInitializationMode_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_enterInitializationMode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_enterInitializationMode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_enterInitializationMode_pargs {
 public:


  virtual ~CoSimulation_enterInitializationMode_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_enterInitializationMode_result__isset {
  _CoSimulation_enterInitializationMode_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_enterInitializationMode_result__isset;

class CoSimulation_enterInitializationMode_result {
 public:

  CoSimulation_enterInitializationMode_result(const CoSimulation_enterInitializationMode_result&);
  CoSimulation_enterInitializationMode_result& operator=(const CoSimulation_enterInitializationMode_result&);
  CoSimulation_enterInitializationMode_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_enterInitializationMode_result() throw();
  Status::type success;

  _CoSimulation_enterInitializationMode_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_enterInitializationMode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_enterInitializationMode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_enterInitializationMode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_enterInitializationMode_presult__isset {
  _CoSimulation_enterInitializationMode_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_enterInitializationMode_presult__isset;

class CoSimulation_enterInitializationMode_presult {
 public:


  virtual ~CoSimulation_enterInitializationMode_presult() throw();
  Status::type* success;

  _CoSimulation_enterInitializationMode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_exitInitializationMode_args__isset {
  _CoSimulation_exitInitializationMode_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_exitInitializationMode_args__isset;

class CoSimulation_exitInitializationMode_args {
 public:

  CoSimulation_exitInitializationMode_args(const CoSimulation_exitInitializationMode_args&);
  CoSimulation_exitInitializationMode_args& operator=(const CoSimulation_exitInitializationMode_args&);
  CoSimulation_exitInitializationMode_args() {
  }

  virtual ~CoSimulation_exitInitializationMode_args() throw();
  Instance c;

  _CoSimulation_exitInitializationMode_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_exitInitializationMode_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_exitInitializationMode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_exitInitializationMode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_exitInitializationMode_pargs {
 public:


  virtual ~CoSimulation_exitInitializationMode_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_exitInitializationMode_result__isset {
  _CoSimulation_exitInitializationMode_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_exitInitializationMode_result__isset;

class CoSimulation_exitInitializationMode_result {
 public:

  CoSimulation_exitInitializationMode_result(const CoSimulation_exitInitializationMode_result&);
  CoSimulation_exitInitializationMode_result& operator=(const CoSimulation_exitInitializationMode_result&);
  CoSimulation_exitInitializationMode_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_exitInitializationMode_result() throw();
  Status::type success;

  _CoSimulation_exitInitializationMode_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_exitInitializationMode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_exitInitializationMode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_exitInitializationMode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_exitInitializationMode_presult__isset {
  _CoSimulation_exitInitializationMode_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_exitInitializationMode_presult__isset;

class CoSimulation_exitInitializationMode_presult {
 public:


  virtual ~CoSimulation_exitInitializationMode_presult() throw();
  Status::type* success;

  _CoSimulation_exitInitializationMode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_terminate_args__isset {
  _CoSimulation_terminate_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_terminate_args__isset;

class CoSimulation_terminate_args {
 public:

  CoSimulation_terminate_args(const CoSimulation_terminate_args&);
  CoSimulation_terminate_args& operator=(const CoSimulation_terminate_args&);
  CoSimulation_terminate_args() {
  }

  virtual ~CoSimulation_terminate_args() throw();
  Instance c;

  _CoSimulation_terminate_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_terminate_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_terminate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_terminate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_terminate_pargs {
 public:


  virtual ~CoSimulation_terminate_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_terminate_result__isset {
  _CoSimulation_terminate_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_terminate_result__isset;

class CoSimulation_terminate_result {
 public:

  CoSimulation_terminate_result(const CoSimulation_terminate_result&);
  CoSimulation_terminate_result& operator=(const CoSimulation_terminate_result&);
  CoSimulation_terminate_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_terminate_result() throw();
  Status::type success;

  _CoSimulation_terminate_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_terminate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_terminate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_terminate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_terminate_presult__isset {
  _CoSimulation_terminate_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_terminate_presult__isset;

class CoSimulation_terminate_presult {
 public:


  virtual ~CoSimulation_terminate_presult() throw();
  Status::type* success;

  _CoSimulation_terminate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_reset_args__isset {
  _CoSimulation_reset_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_reset_args__isset;

class CoSimulation_reset_args {
 public:

  CoSimulation_reset_args(const CoSimulation_reset_args&);
  CoSimulation_reset_args& operator=(const CoSimulation_reset_args&);
  CoSimulation_reset_args() {
  }

  virtual ~CoSimulation_reset_args() throw();
  Instance c;

  _CoSimulation_reset_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_reset_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_reset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_reset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_reset_pargs {
 public:


  virtual ~CoSimulation_reset_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_reset_result__isset {
  _CoSimulation_reset_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_reset_result__isset;

class CoSimulation_reset_result {
 public:

  CoSimulation_reset_result(const CoSimulation_reset_result&);
  CoSimulation_reset_result& operator=(const CoSimulation_reset_result&);
  CoSimulation_reset_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_reset_result() throw();
  Status::type success;

  _CoSimulation_reset_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_reset_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_reset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_reset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_reset_presult__isset {
  _CoSimulation_reset_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_reset_presult__isset;

class CoSimulation_reset_presult {
 public:


  virtual ~CoSimulation_reset_presult() throw();
  Status::type* success;

  _CoSimulation_reset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_freeInstance_args__isset {
  _CoSimulation_freeInstance_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_freeInstance_args__isset;

class CoSimulation_freeInstance_args {
 public:

  CoSimulation_freeInstance_args(const CoSimulation_freeInstance_args&);
  CoSimulation_freeInstance_args& operator=(const CoSimulation_freeInstance_args&);
  CoSimulation_freeInstance_args() {
  }

  virtual ~CoSimulation_freeInstance_args() throw();
  Instance c;

  _CoSimulation_freeInstance_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_freeInstance_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_freeInstance_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_freeInstance_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_freeInstance_pargs {
 public:


  virtual ~CoSimulation_freeInstance_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_freeInstance_result {
 public:

  CoSimulation_freeInstance_result(const CoSimulation_freeInstance_result&);
  CoSimulation_freeInstance_result& operator=(const CoSimulation_freeInstance_result&);
  CoSimulation_freeInstance_result() {
  }

  virtual ~CoSimulation_freeInstance_result() throw();

  bool operator == (const CoSimulation_freeInstance_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const CoSimulation_freeInstance_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_freeInstance_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_freeInstance_presult {
 public:


  virtual ~CoSimulation_freeInstance_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getReal_args__isset {
  _CoSimulation_getReal_args__isset() : c(false), refs(false) {}
  bool c :1;
  bool refs :1;
} _CoSimulation_getReal_args__isset;

class CoSimulation_getReal_args {
 public:

  CoSimulation_getReal_args(const CoSimulation_getReal_args&);
  CoSimulation_getReal_args& operator=(const CoSimulation_getReal_args&);
  CoSimulation_getReal_args() {
  }

  virtual ~CoSimulation_getReal_args() throw();
  Instance c;
  std::vector<int32_t>  refs;

  _CoSimulation_getReal_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_refs(const std::vector<int32_t> & val);

  bool operator == (const CoSimulation_getReal_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(refs == rhs.refs))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getReal_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getReal_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getReal_pargs {
 public:


  virtual ~CoSimulation_getReal_pargs() throw();
  const Instance* c;
  const std::vector<int32_t> * refs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getReal_result__isset {
  _CoSimulation_getReal_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getReal_result__isset;

class CoSimulation_getReal_result {
 public:

  CoSimulation_getReal_result(const CoSimulation_getReal_result&);
  CoSimulation_getReal_result& operator=(const CoSimulation_getReal_result&);
  CoSimulation_getReal_result() {
  }

  virtual ~CoSimulation_getReal_result() throw();
  std::vector<double>  success;

  _CoSimulation_getReal_result__isset __isset;

  void __set_success(const std::vector<double> & val);

  bool operator == (const CoSimulation_getReal_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getReal_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getReal_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getReal_presult__isset {
  _CoSimulation_getReal_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getReal_presult__isset;

class CoSimulation_getReal_presult {
 public:


  virtual ~CoSimulation_getReal_presult() throw();
  std::vector<double> * success;

  _CoSimulation_getReal_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getInteger_args__isset {
  _CoSimulation_getInteger_args__isset() : c(false), refs(false) {}
  bool c :1;
  bool refs :1;
} _CoSimulation_getInteger_args__isset;

class CoSimulation_getInteger_args {
 public:

  CoSimulation_getInteger_args(const CoSimulation_getInteger_args&);
  CoSimulation_getInteger_args& operator=(const CoSimulation_getInteger_args&);
  CoSimulation_getInteger_args() {
  }

  virtual ~CoSimulation_getInteger_args() throw();
  Instance c;
  std::vector<int32_t>  refs;

  _CoSimulation_getInteger_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_refs(const std::vector<int32_t> & val);

  bool operator == (const CoSimulation_getInteger_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(refs == rhs.refs))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getInteger_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getInteger_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getInteger_pargs {
 public:


  virtual ~CoSimulation_getInteger_pargs() throw();
  const Instance* c;
  const std::vector<int32_t> * refs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getInteger_result__isset {
  _CoSimulation_getInteger_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getInteger_result__isset;

class CoSimulation_getInteger_result {
 public:

  CoSimulation_getInteger_result(const CoSimulation_getInteger_result&);
  CoSimulation_getInteger_result& operator=(const CoSimulation_getInteger_result&);
  CoSimulation_getInteger_result() {
  }

  virtual ~CoSimulation_getInteger_result() throw();
  std::vector<int32_t>  success;

  _CoSimulation_getInteger_result__isset __isset;

  void __set_success(const std::vector<int32_t> & val);

  bool operator == (const CoSimulation_getInteger_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getInteger_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getInteger_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getInteger_presult__isset {
  _CoSimulation_getInteger_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getInteger_presult__isset;

class CoSimulation_getInteger_presult {
 public:


  virtual ~CoSimulation_getInteger_presult() throw();
  std::vector<int32_t> * success;

  _CoSimulation_getInteger_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getBoolean_args__isset {
  _CoSimulation_getBoolean_args__isset() : c(false), refs(false) {}
  bool c :1;
  bool refs :1;
} _CoSimulation_getBoolean_args__isset;

class CoSimulation_getBoolean_args {
 public:

  CoSimulation_getBoolean_args(const CoSimulation_getBoolean_args&);
  CoSimulation_getBoolean_args& operator=(const CoSimulation_getBoolean_args&);
  CoSimulation_getBoolean_args() {
  }

  virtual ~CoSimulation_getBoolean_args() throw();
  Instance c;
  std::vector<int32_t>  refs;

  _CoSimulation_getBoolean_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_refs(const std::vector<int32_t> & val);

  bool operator == (const CoSimulation_getBoolean_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(refs == rhs.refs))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getBoolean_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getBoolean_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getBoolean_pargs {
 public:


  virtual ~CoSimulation_getBoolean_pargs() throw();
  const Instance* c;
  const std::vector<int32_t> * refs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getBoolean_result__isset {
  _CoSimulation_getBoolean_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getBoolean_result__isset;

class CoSimulation_getBoolean_result {
 public:

  CoSimulation_getBoolean_result(const CoSimulation_getBoolean_result&);
  CoSimulation_getBoolean_result& operator=(const CoSimulation_getBoolean_result&);
  CoSimulation_getBoolean_result() {
  }

  virtual ~CoSimulation_getBoolean_result() throw();
  std::vector<bool>  success;

  _CoSimulation_getBoolean_result__isset __isset;

  void __set_success(const std::vector<bool> & val);

  bool operator == (const CoSimulation_getBoolean_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getBoolean_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getBoolean_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getBoolean_presult__isset {
  _CoSimulation_getBoolean_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getBoolean_presult__isset;

class CoSimulation_getBoolean_presult {
 public:


  virtual ~CoSimulation_getBoolean_presult() throw();
  std::vector<bool> * success;

  _CoSimulation_getBoolean_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getString_args__isset {
  _CoSimulation_getString_args__isset() : c(false), refs(false) {}
  bool c :1;
  bool refs :1;
} _CoSimulation_getString_args__isset;

class CoSimulation_getString_args {
 public:

  CoSimulation_getString_args(const CoSimulation_getString_args&);
  CoSimulation_getString_args& operator=(const CoSimulation_getString_args&);
  CoSimulation_getString_args() {
  }

  virtual ~CoSimulation_getString_args() throw();
  Instance c;
  std::vector<int32_t>  refs;

  _CoSimulation_getString_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_refs(const std::vector<int32_t> & val);

  bool operator == (const CoSimulation_getString_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(refs == rhs.refs))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getString_pargs {
 public:


  virtual ~CoSimulation_getString_pargs() throw();
  const Instance* c;
  const std::vector<int32_t> * refs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getString_result__isset {
  _CoSimulation_getString_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getString_result__isset;

class CoSimulation_getString_result {
 public:

  CoSimulation_getString_result(const CoSimulation_getString_result&);
  CoSimulation_getString_result& operator=(const CoSimulation_getString_result&);
  CoSimulation_getString_result() {
  }

  virtual ~CoSimulation_getString_result() throw();
  std::vector<std::string>  success;

  _CoSimulation_getString_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  bool operator == (const CoSimulation_getString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getString_presult__isset {
  _CoSimulation_getString_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getString_presult__isset;

class CoSimulation_getString_presult {
 public:


  virtual ~CoSimulation_getString_presult() throw();
  std::vector<std::string> * success;

  _CoSimulation_getString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setReal_args__isset {
  _CoSimulation_setReal_args__isset() : c(false), ref_values(false) {}
  bool c :1;
  bool ref_values :1;
} _CoSimulation_setReal_args__isset;

class CoSimulation_setReal_args {
 public:

  CoSimulation_setReal_args(const CoSimulation_setReal_args&);
  CoSimulation_setReal_args& operator=(const CoSimulation_setReal_args&);
  CoSimulation_setReal_args() {
  }

  virtual ~CoSimulation_setReal_args() throw();
  Instance c;
  std::map<int32_t, double>  ref_values;

  _CoSimulation_setReal_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_values(const std::map<int32_t, double> & val);

  bool operator == (const CoSimulation_setReal_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setReal_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setReal_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setReal_pargs {
 public:


  virtual ~CoSimulation_setReal_pargs() throw();
  const Instance* c;
  const std::map<int32_t, double> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setReal_result__isset {
  _CoSimulation_setReal_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setReal_result__isset;

class CoSimulation_setReal_result {
 public:

  CoSimulation_setReal_result(const CoSimulation_setReal_result&);
  CoSimulation_setReal_result& operator=(const CoSimulation_setReal_result&);
  CoSimulation_setReal_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setReal_result() throw();
  Status::type success;

  _CoSimulation_setReal_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setReal_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setReal_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setReal_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setReal_presult__isset {
  _CoSimulation_setReal_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setReal_presult__isset;

class CoSimulation_setReal_presult {
 public:


  virtual ~CoSimulation_setReal_presult() throw();
  Status::type* success;

  _CoSimulation_setReal_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setInteger_args__isset {
  _CoSimulation_setInteger_args__isset() : c(false), ref_values(false) {}
  bool c :1;
  bool ref_values :1;
} _CoSimulation_setInteger_args__isset;

class CoSimulation_setInteger_args {
 public:

  CoSimulation_setInteger_args(const CoSimulation_setInteger_args&);
  CoSimulation_setInteger_args& operator=(const CoSimulation_setInteger_args&);
  CoSimulation_setInteger_args() {
  }

  virtual ~CoSimulation_setInteger_args() throw();
  Instance c;
  std::map<int32_t, int32_t>  ref_values;

  _CoSimulation_setInteger_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_values(const std::map<int32_t, int32_t> & val);

  bool operator == (const CoSimulation_setInteger_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setInteger_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setInteger_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setInteger_pargs {
 public:


  virtual ~CoSimulation_setInteger_pargs() throw();
  const Instance* c;
  const std::map<int32_t, int32_t> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setInteger_result__isset {
  _CoSimulation_setInteger_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setInteger_result__isset;

class CoSimulation_setInteger_result {
 public:

  CoSimulation_setInteger_result(const CoSimulation_setInteger_result&);
  CoSimulation_setInteger_result& operator=(const CoSimulation_setInteger_result&);
  CoSimulation_setInteger_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setInteger_result() throw();
  Status::type success;

  _CoSimulation_setInteger_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setInteger_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setInteger_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setInteger_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setInteger_presult__isset {
  _CoSimulation_setInteger_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setInteger_presult__isset;

class CoSimulation_setInteger_presult {
 public:


  virtual ~CoSimulation_setInteger_presult() throw();
  Status::type* success;

  _CoSimulation_setInteger_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setBoolean_args__isset {
  _CoSimulation_setBoolean_args__isset() : c(false), ref_values(false) {}
  bool c :1;
  bool ref_values :1;
} _CoSimulation_setBoolean_args__isset;

class CoSimulation_setBoolean_args {
 public:

  CoSimulation_setBoolean_args(const CoSimulation_setBoolean_args&);
  CoSimulation_setBoolean_args& operator=(const CoSimulation_setBoolean_args&);
  CoSimulation_setBoolean_args() {
  }

  virtual ~CoSimulation_setBoolean_args() throw();
  Instance c;
  std::map<int32_t, bool>  ref_values;

  _CoSimulation_setBoolean_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_values(const std::map<int32_t, bool> & val);

  bool operator == (const CoSimulation_setBoolean_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setBoolean_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setBoolean_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setBoolean_pargs {
 public:


  virtual ~CoSimulation_setBoolean_pargs() throw();
  const Instance* c;
  const std::map<int32_t, bool> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setBoolean_result__isset {
  _CoSimulation_setBoolean_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setBoolean_result__isset;

class CoSimulation_setBoolean_result {
 public:

  CoSimulation_setBoolean_result(const CoSimulation_setBoolean_result&);
  CoSimulation_setBoolean_result& operator=(const CoSimulation_setBoolean_result&);
  CoSimulation_setBoolean_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setBoolean_result() throw();
  Status::type success;

  _CoSimulation_setBoolean_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setBoolean_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setBoolean_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setBoolean_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setBoolean_presult__isset {
  _CoSimulation_setBoolean_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setBoolean_presult__isset;

class CoSimulation_setBoolean_presult {
 public:


  virtual ~CoSimulation_setBoolean_presult() throw();
  Status::type* success;

  _CoSimulation_setBoolean_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setString_args__isset {
  _CoSimulation_setString_args__isset() : c(false), ref_values(false) {}
  bool c :1;
  bool ref_values :1;
} _CoSimulation_setString_args__isset;

class CoSimulation_setString_args {
 public:

  CoSimulation_setString_args(const CoSimulation_setString_args&);
  CoSimulation_setString_args& operator=(const CoSimulation_setString_args&);
  CoSimulation_setString_args() {
  }

  virtual ~CoSimulation_setString_args() throw();
  Instance c;
  std::map<int32_t, std::string>  ref_values;

  _CoSimulation_setString_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_values(const std::map<int32_t, std::string> & val);

  bool operator == (const CoSimulation_setString_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setString_pargs {
 public:


  virtual ~CoSimulation_setString_pargs() throw();
  const Instance* c;
  const std::map<int32_t, std::string> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setString_result__isset {
  _CoSimulation_setString_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setString_result__isset;

class CoSimulation_setString_result {
 public:

  CoSimulation_setString_result(const CoSimulation_setString_result&);
  CoSimulation_setString_result& operator=(const CoSimulation_setString_result&);
  CoSimulation_setString_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setString_result() throw();
  Status::type success;

  _CoSimulation_setString_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setString_presult__isset {
  _CoSimulation_setString_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setString_presult__isset;

class CoSimulation_setString_presult {
 public:


  virtual ~CoSimulation_setString_presult() throw();
  Status::type* success;

  _CoSimulation_setString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setRealInputDerivatives_args__isset {
  _CoSimulation_setRealInputDerivatives_args__isset() : c(false), ref_orders(false), ref_values(false) {}
  bool c :1;
  bool ref_orders :1;
  bool ref_values :1;
} _CoSimulation_setRealInputDerivatives_args__isset;

class CoSimulation_setRealInputDerivatives_args {
 public:

  CoSimulation_setRealInputDerivatives_args(const CoSimulation_setRealInputDerivatives_args&);
  CoSimulation_setRealInputDerivatives_args& operator=(const CoSimulation_setRealInputDerivatives_args&);
  CoSimulation_setRealInputDerivatives_args() {
  }

  virtual ~CoSimulation_setRealInputDerivatives_args() throw();
  Instance c;
  std::map<int32_t, int32_t>  ref_orders;
  std::map<int32_t, double>  ref_values;

  _CoSimulation_setRealInputDerivatives_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_orders(const std::map<int32_t, int32_t> & val);

  void __set_ref_values(const std::map<int32_t, double> & val);

  bool operator == (const CoSimulation_setRealInputDerivatives_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_orders == rhs.ref_orders))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setRealInputDerivatives_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setRealInputDerivatives_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setRealInputDerivatives_pargs {
 public:


  virtual ~CoSimulation_setRealInputDerivatives_pargs() throw();
  const Instance* c;
  const std::map<int32_t, int32_t> * ref_orders;
  const std::map<int32_t, double> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setRealInputDerivatives_result__isset {
  _CoSimulation_setRealInputDerivatives_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setRealInputDerivatives_result__isset;

class CoSimulation_setRealInputDerivatives_result {
 public:

  CoSimulation_setRealInputDerivatives_result(const CoSimulation_setRealInputDerivatives_result&);
  CoSimulation_setRealInputDerivatives_result& operator=(const CoSimulation_setRealInputDerivatives_result&);
  CoSimulation_setRealInputDerivatives_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setRealInputDerivatives_result() throw();
  Status::type success;

  _CoSimulation_setRealInputDerivatives_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setRealInputDerivatives_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setRealInputDerivatives_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setRealInputDerivatives_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setRealInputDerivatives_presult__isset {
  _CoSimulation_setRealInputDerivatives_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setRealInputDerivatives_presult__isset;

class CoSimulation_setRealInputDerivatives_presult {
 public:


  virtual ~CoSimulation_setRealInputDerivatives_presult() throw();
  Status::type* success;

  _CoSimulation_setRealInputDerivatives_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_setRealOutputDerivatives_args__isset {
  _CoSimulation_setRealOutputDerivatives_args__isset() : c(false), ref_orders(false), ref_values(false) {}
  bool c :1;
  bool ref_orders :1;
  bool ref_values :1;
} _CoSimulation_setRealOutputDerivatives_args__isset;

class CoSimulation_setRealOutputDerivatives_args {
 public:

  CoSimulation_setRealOutputDerivatives_args(const CoSimulation_setRealOutputDerivatives_args&);
  CoSimulation_setRealOutputDerivatives_args& operator=(const CoSimulation_setRealOutputDerivatives_args&);
  CoSimulation_setRealOutputDerivatives_args() {
  }

  virtual ~CoSimulation_setRealOutputDerivatives_args() throw();
  Instance c;
  std::map<int32_t, int32_t>  ref_orders;
  std::map<int32_t, double>  ref_values;

  _CoSimulation_setRealOutputDerivatives_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_ref_orders(const std::map<int32_t, int32_t> & val);

  void __set_ref_values(const std::map<int32_t, double> & val);

  bool operator == (const CoSimulation_setRealOutputDerivatives_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ref_orders == rhs.ref_orders))
      return false;
    if (!(ref_values == rhs.ref_values))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setRealOutputDerivatives_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setRealOutputDerivatives_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_setRealOutputDerivatives_pargs {
 public:


  virtual ~CoSimulation_setRealOutputDerivatives_pargs() throw();
  const Instance* c;
  const std::map<int32_t, int32_t> * ref_orders;
  const std::map<int32_t, double> * ref_values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setRealOutputDerivatives_result__isset {
  _CoSimulation_setRealOutputDerivatives_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setRealOutputDerivatives_result__isset;

class CoSimulation_setRealOutputDerivatives_result {
 public:

  CoSimulation_setRealOutputDerivatives_result(const CoSimulation_setRealOutputDerivatives_result&);
  CoSimulation_setRealOutputDerivatives_result& operator=(const CoSimulation_setRealOutputDerivatives_result&);
  CoSimulation_setRealOutputDerivatives_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_setRealOutputDerivatives_result() throw();
  Status::type success;

  _CoSimulation_setRealOutputDerivatives_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_setRealOutputDerivatives_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_setRealOutputDerivatives_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_setRealOutputDerivatives_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_setRealOutputDerivatives_presult__isset {
  _CoSimulation_setRealOutputDerivatives_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_setRealOutputDerivatives_presult__isset;

class CoSimulation_setRealOutputDerivatives_presult {
 public:


  virtual ~CoSimulation_setRealOutputDerivatives_presult() throw();
  Status::type* success;

  _CoSimulation_setRealOutputDerivatives_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_cancelStep_args__isset {
  _CoSimulation_cancelStep_args__isset() : c(false) {}
  bool c :1;
} _CoSimulation_cancelStep_args__isset;

class CoSimulation_cancelStep_args {
 public:

  CoSimulation_cancelStep_args(const CoSimulation_cancelStep_args&);
  CoSimulation_cancelStep_args& operator=(const CoSimulation_cancelStep_args&);
  CoSimulation_cancelStep_args() {
  }

  virtual ~CoSimulation_cancelStep_args() throw();
  Instance c;

  _CoSimulation_cancelStep_args__isset __isset;

  void __set_c(const Instance& val);

  bool operator == (const CoSimulation_cancelStep_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_cancelStep_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_cancelStep_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_cancelStep_pargs {
 public:


  virtual ~CoSimulation_cancelStep_pargs() throw();
  const Instance* c;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_cancelStep_result__isset {
  _CoSimulation_cancelStep_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_cancelStep_result__isset;

class CoSimulation_cancelStep_result {
 public:

  CoSimulation_cancelStep_result(const CoSimulation_cancelStep_result&);
  CoSimulation_cancelStep_result& operator=(const CoSimulation_cancelStep_result&);
  CoSimulation_cancelStep_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_cancelStep_result() throw();
  Status::type success;

  _CoSimulation_cancelStep_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_cancelStep_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_cancelStep_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_cancelStep_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_cancelStep_presult__isset {
  _CoSimulation_cancelStep_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_cancelStep_presult__isset;

class CoSimulation_cancelStep_presult {
 public:


  virtual ~CoSimulation_cancelStep_presult() throw();
  Status::type* success;

  _CoSimulation_cancelStep_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_doStep_args__isset {
  _CoSimulation_doStep_args__isset() : c(false), currentCommunicationPoint(false), communicationStepSize(false), noSetFMUStatePriorToCurrentPoint(false) {}
  bool c :1;
  bool currentCommunicationPoint :1;
  bool communicationStepSize :1;
  bool noSetFMUStatePriorToCurrentPoint :1;
} _CoSimulation_doStep_args__isset;

class CoSimulation_doStep_args {
 public:

  CoSimulation_doStep_args(const CoSimulation_doStep_args&);
  CoSimulation_doStep_args& operator=(const CoSimulation_doStep_args&);
  CoSimulation_doStep_args() : currentCommunicationPoint(0), communicationStepSize(0), noSetFMUStatePriorToCurrentPoint(0) {
  }

  virtual ~CoSimulation_doStep_args() throw();
  Instance c;
  double currentCommunicationPoint;
  double communicationStepSize;
  bool noSetFMUStatePriorToCurrentPoint;

  _CoSimulation_doStep_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_currentCommunicationPoint(const double val);

  void __set_communicationStepSize(const double val);

  void __set_noSetFMUStatePriorToCurrentPoint(const bool val);

  bool operator == (const CoSimulation_doStep_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(currentCommunicationPoint == rhs.currentCommunicationPoint))
      return false;
    if (!(communicationStepSize == rhs.communicationStepSize))
      return false;
    if (!(noSetFMUStatePriorToCurrentPoint == rhs.noSetFMUStatePriorToCurrentPoint))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_doStep_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_doStep_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_doStep_pargs {
 public:


  virtual ~CoSimulation_doStep_pargs() throw();
  const Instance* c;
  const double* currentCommunicationPoint;
  const double* communicationStepSize;
  const bool* noSetFMUStatePriorToCurrentPoint;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_doStep_result__isset {
  _CoSimulation_doStep_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_doStep_result__isset;

class CoSimulation_doStep_result {
 public:

  CoSimulation_doStep_result(const CoSimulation_doStep_result&);
  CoSimulation_doStep_result& operator=(const CoSimulation_doStep_result&);
  CoSimulation_doStep_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_doStep_result() throw();
  Status::type success;

  _CoSimulation_doStep_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_doStep_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_doStep_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_doStep_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_doStep_presult__isset {
  _CoSimulation_doStep_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_doStep_presult__isset;

class CoSimulation_doStep_presult {
 public:


  virtual ~CoSimulation_doStep_presult() throw();
  Status::type* success;

  _CoSimulation_doStep_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getStatus_args__isset {
  _CoSimulation_getStatus_args__isset() : c(false), s(false) {}
  bool c :1;
  bool s :1;
} _CoSimulation_getStatus_args__isset;

class CoSimulation_getStatus_args {
 public:

  CoSimulation_getStatus_args(const CoSimulation_getStatus_args&);
  CoSimulation_getStatus_args& operator=(const CoSimulation_getStatus_args&);
  CoSimulation_getStatus_args() : s((StatusKind::type)0) {
  }

  virtual ~CoSimulation_getStatus_args() throw();
  Instance c;
  StatusKind::type s;

  _CoSimulation_getStatus_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_s(const StatusKind::type val);

  bool operator == (const CoSimulation_getStatus_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getStatus_pargs {
 public:


  virtual ~CoSimulation_getStatus_pargs() throw();
  const Instance* c;
  const StatusKind::type* s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getStatus_result__isset {
  _CoSimulation_getStatus_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getStatus_result__isset;

class CoSimulation_getStatus_result {
 public:

  CoSimulation_getStatus_result(const CoSimulation_getStatus_result&);
  CoSimulation_getStatus_result& operator=(const CoSimulation_getStatus_result&);
  CoSimulation_getStatus_result() : success((Status::type)0) {
  }

  virtual ~CoSimulation_getStatus_result() throw();
  Status::type success;

  _CoSimulation_getStatus_result__isset __isset;

  void __set_success(const Status::type val);

  bool operator == (const CoSimulation_getStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getStatus_presult__isset {
  _CoSimulation_getStatus_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getStatus_presult__isset;

class CoSimulation_getStatus_presult {
 public:


  virtual ~CoSimulation_getStatus_presult() throw();
  Status::type* success;

  _CoSimulation_getStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getIntegerStatus_args__isset {
  _CoSimulation_getIntegerStatus_args__isset() : c(false), s(false) {}
  bool c :1;
  bool s :1;
} _CoSimulation_getIntegerStatus_args__isset;

class CoSimulation_getIntegerStatus_args {
 public:

  CoSimulation_getIntegerStatus_args(const CoSimulation_getIntegerStatus_args&);
  CoSimulation_getIntegerStatus_args& operator=(const CoSimulation_getIntegerStatus_args&);
  CoSimulation_getIntegerStatus_args() : s((StatusKind::type)0) {
  }

  virtual ~CoSimulation_getIntegerStatus_args() throw();
  Instance c;
  StatusKind::type s;

  _CoSimulation_getIntegerStatus_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_s(const StatusKind::type val);

  bool operator == (const CoSimulation_getIntegerStatus_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getIntegerStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getIntegerStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getIntegerStatus_pargs {
 public:


  virtual ~CoSimulation_getIntegerStatus_pargs() throw();
  const Instance* c;
  const StatusKind::type* s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getIntegerStatus_result__isset {
  _CoSimulation_getIntegerStatus_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getIntegerStatus_result__isset;

class CoSimulation_getIntegerStatus_result {
 public:

  CoSimulation_getIntegerStatus_result(const CoSimulation_getIntegerStatus_result&);
  CoSimulation_getIntegerStatus_result& operator=(const CoSimulation_getIntegerStatus_result&);
  CoSimulation_getIntegerStatus_result() : success(0) {
  }

  virtual ~CoSimulation_getIntegerStatus_result() throw();
  int32_t success;

  _CoSimulation_getIntegerStatus_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const CoSimulation_getIntegerStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getIntegerStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getIntegerStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getIntegerStatus_presult__isset {
  _CoSimulation_getIntegerStatus_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getIntegerStatus_presult__isset;

class CoSimulation_getIntegerStatus_presult {
 public:


  virtual ~CoSimulation_getIntegerStatus_presult() throw();
  int32_t* success;

  _CoSimulation_getIntegerStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getRealStatus_args__isset {
  _CoSimulation_getRealStatus_args__isset() : c(false), s(false) {}
  bool c :1;
  bool s :1;
} _CoSimulation_getRealStatus_args__isset;

class CoSimulation_getRealStatus_args {
 public:

  CoSimulation_getRealStatus_args(const CoSimulation_getRealStatus_args&);
  CoSimulation_getRealStatus_args& operator=(const CoSimulation_getRealStatus_args&);
  CoSimulation_getRealStatus_args() : s((StatusKind::type)0) {
  }

  virtual ~CoSimulation_getRealStatus_args() throw();
  Instance c;
  StatusKind::type s;

  _CoSimulation_getRealStatus_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_s(const StatusKind::type val);

  bool operator == (const CoSimulation_getRealStatus_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getRealStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getRealStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getRealStatus_pargs {
 public:


  virtual ~CoSimulation_getRealStatus_pargs() throw();
  const Instance* c;
  const StatusKind::type* s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getRealStatus_result__isset {
  _CoSimulation_getRealStatus_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getRealStatus_result__isset;

class CoSimulation_getRealStatus_result {
 public:

  CoSimulation_getRealStatus_result(const CoSimulation_getRealStatus_result&);
  CoSimulation_getRealStatus_result& operator=(const CoSimulation_getRealStatus_result&);
  CoSimulation_getRealStatus_result() : success(0) {
  }

  virtual ~CoSimulation_getRealStatus_result() throw();
  double success;

  _CoSimulation_getRealStatus_result__isset __isset;

  void __set_success(const double val);

  bool operator == (const CoSimulation_getRealStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getRealStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getRealStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getRealStatus_presult__isset {
  _CoSimulation_getRealStatus_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getRealStatus_presult__isset;

class CoSimulation_getRealStatus_presult {
 public:


  virtual ~CoSimulation_getRealStatus_presult() throw();
  double* success;

  _CoSimulation_getRealStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getBooleanStatus_args__isset {
  _CoSimulation_getBooleanStatus_args__isset() : c(false), s(false) {}
  bool c :1;
  bool s :1;
} _CoSimulation_getBooleanStatus_args__isset;

class CoSimulation_getBooleanStatus_args {
 public:

  CoSimulation_getBooleanStatus_args(const CoSimulation_getBooleanStatus_args&);
  CoSimulation_getBooleanStatus_args& operator=(const CoSimulation_getBooleanStatus_args&);
  CoSimulation_getBooleanStatus_args() : s((StatusKind::type)0) {
  }

  virtual ~CoSimulation_getBooleanStatus_args() throw();
  Instance c;
  StatusKind::type s;

  _CoSimulation_getBooleanStatus_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_s(const StatusKind::type val);

  bool operator == (const CoSimulation_getBooleanStatus_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getBooleanStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getBooleanStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getBooleanStatus_pargs {
 public:


  virtual ~CoSimulation_getBooleanStatus_pargs() throw();
  const Instance* c;
  const StatusKind::type* s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getBooleanStatus_result__isset {
  _CoSimulation_getBooleanStatus_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getBooleanStatus_result__isset;

class CoSimulation_getBooleanStatus_result {
 public:

  CoSimulation_getBooleanStatus_result(const CoSimulation_getBooleanStatus_result&);
  CoSimulation_getBooleanStatus_result& operator=(const CoSimulation_getBooleanStatus_result&);
  CoSimulation_getBooleanStatus_result() : success(0) {
  }

  virtual ~CoSimulation_getBooleanStatus_result() throw();
  bool success;

  _CoSimulation_getBooleanStatus_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const CoSimulation_getBooleanStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getBooleanStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getBooleanStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getBooleanStatus_presult__isset {
  _CoSimulation_getBooleanStatus_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getBooleanStatus_presult__isset;

class CoSimulation_getBooleanStatus_presult {
 public:


  virtual ~CoSimulation_getBooleanStatus_presult() throw();
  bool* success;

  _CoSimulation_getBooleanStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _CoSimulation_getStringStatus_args__isset {
  _CoSimulation_getStringStatus_args__isset() : c(false), s(false) {}
  bool c :1;
  bool s :1;
} _CoSimulation_getStringStatus_args__isset;

class CoSimulation_getStringStatus_args {
 public:

  CoSimulation_getStringStatus_args(const CoSimulation_getStringStatus_args&);
  CoSimulation_getStringStatus_args& operator=(const CoSimulation_getStringStatus_args&);
  CoSimulation_getStringStatus_args() : s((StatusKind::type)0) {
  }

  virtual ~CoSimulation_getStringStatus_args() throw();
  Instance c;
  StatusKind::type s;

  _CoSimulation_getStringStatus_args__isset __isset;

  void __set_c(const Instance& val);

  void __set_s(const StatusKind::type val);

  bool operator == (const CoSimulation_getStringStatus_args & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(s == rhs.s))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getStringStatus_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getStringStatus_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class CoSimulation_getStringStatus_pargs {
 public:


  virtual ~CoSimulation_getStringStatus_pargs() throw();
  const Instance* c;
  const StatusKind::type* s;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getStringStatus_result__isset {
  _CoSimulation_getStringStatus_result__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getStringStatus_result__isset;

class CoSimulation_getStringStatus_result {
 public:

  CoSimulation_getStringStatus_result(const CoSimulation_getStringStatus_result&);
  CoSimulation_getStringStatus_result& operator=(const CoSimulation_getStringStatus_result&);
  CoSimulation_getStringStatus_result() : success() {
  }

  virtual ~CoSimulation_getStringStatus_result() throw();
  std::string success;

  _CoSimulation_getStringStatus_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const CoSimulation_getStringStatus_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const CoSimulation_getStringStatus_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoSimulation_getStringStatus_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _CoSimulation_getStringStatus_presult__isset {
  _CoSimulation_getStringStatus_presult__isset() : success(false) {}
  bool success :1;
} _CoSimulation_getStringStatus_presult__isset;

class CoSimulation_getStringStatus_presult {
 public:


  virtual ~CoSimulation_getStringStatus_presult() throw();
  std::string* success;

  _CoSimulation_getStringStatus_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class CoSimulationClient : virtual public CoSimulationIf {
 public:
  CoSimulationClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  CoSimulationClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getVersion(std::string& _return);
  void send_getVersion();
  void recv_getVersion(std::string& _return);
  void getTypesPlatform(std::string& _return);
  void send_getTypesPlatform();
  void recv_getTypesPlatform(std::string& _return);
  void instanciate(Instance& _return, const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn);
  void send_instanciate(const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn);
  void recv_instanciate(Instance& _return);
  Status::type setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime);
  void send_setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime);
  Status::type recv_setupExperiment();
  Status::type enterInitializationMode(const Instance& c);
  void send_enterInitializationMode(const Instance& c);
  Status::type recv_enterInitializationMode();
  Status::type exitInitializationMode(const Instance& c);
  void send_exitInitializationMode(const Instance& c);
  Status::type recv_exitInitializationMode();
  Status::type terminate(const Instance& c);
  void send_terminate(const Instance& c);
  Status::type recv_terminate();
  Status::type reset(const Instance& c);
  void send_reset(const Instance& c);
  Status::type recv_reset();
  void freeInstance(const Instance& c);
  void send_freeInstance(const Instance& c);
  void recv_freeInstance();
  void getReal(std::vector<double> & _return, const Instance& c, const std::vector<int32_t> & refs);
  void send_getReal(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getReal(std::vector<double> & _return);
  void getInteger(std::vector<int32_t> & _return, const Instance& c, const std::vector<int32_t> & refs);
  void send_getInteger(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getInteger(std::vector<int32_t> & _return);
  void getBoolean(std::vector<bool> & _return, const Instance& c, const std::vector<int32_t> & refs);
  void send_getBoolean(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getBoolean(std::vector<bool> & _return);
  void getString(std::vector<std::string> & _return, const Instance& c, const std::vector<int32_t> & refs);
  void send_getString(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getString(std::vector<std::string> & _return);
  Status::type setReal(const Instance& c, const std::map<int32_t, double> & ref_values);
  void send_setReal(const Instance& c, const std::map<int32_t, double> & ref_values);
  Status::type recv_setReal();
  Status::type setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values);
  void send_setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values);
  Status::type recv_setInteger();
  Status::type setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values);
  void send_setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values);
  Status::type recv_setBoolean();
  Status::type setString(const Instance& c, const std::map<int32_t, std::string> & ref_values);
  void send_setString(const Instance& c, const std::map<int32_t, std::string> & ref_values);
  Status::type recv_setString();
  Status::type setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  void send_setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  Status::type recv_setRealInputDerivatives();
  Status::type setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  void send_setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  Status::type recv_setRealOutputDerivatives();
  Status::type cancelStep(const Instance& c);
  void send_cancelStep(const Instance& c);
  Status::type recv_cancelStep();
  Status::type doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint);
  void send_doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint);
  Status::type recv_doStep();
  Status::type getStatus(const Instance& c, const StatusKind::type s);
  void send_getStatus(const Instance& c, const StatusKind::type s);
  Status::type recv_getStatus();
  int32_t getIntegerStatus(const Instance& c, const StatusKind::type s);
  void send_getIntegerStatus(const Instance& c, const StatusKind::type s);
  int32_t recv_getIntegerStatus();
  double getRealStatus(const Instance& c, const StatusKind::type s);
  void send_getRealStatus(const Instance& c, const StatusKind::type s);
  double recv_getRealStatus();
  bool getBooleanStatus(const Instance& c, const StatusKind::type s);
  void send_getBooleanStatus(const Instance& c, const StatusKind::type s);
  bool recv_getBooleanStatus();
  void getStringStatus(std::string& _return, const Instance& c, const StatusKind::type s);
  void send_getStringStatus(const Instance& c, const StatusKind::type s);
  void recv_getStringStatus(std::string& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class CoSimulationProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<CoSimulationIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (CoSimulationProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTypesPlatform(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_instanciate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setupExperiment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enterInitializationMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exitInitializationMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_terminate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_reset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_freeInstance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getReal(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getInteger(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getBoolean(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setReal(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setInteger(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setBoolean(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setRealInputDerivatives(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setRealOutputDerivatives(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cancelStep(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_doStep(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getIntegerStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRealStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getBooleanStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getStringStatus(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  CoSimulationProcessor(boost::shared_ptr<CoSimulationIf> iface) :
    iface_(iface) {
    processMap_["getVersion"] = &CoSimulationProcessor::process_getVersion;
    processMap_["getTypesPlatform"] = &CoSimulationProcessor::process_getTypesPlatform;
    processMap_["instanciate"] = &CoSimulationProcessor::process_instanciate;
    processMap_["setupExperiment"] = &CoSimulationProcessor::process_setupExperiment;
    processMap_["enterInitializationMode"] = &CoSimulationProcessor::process_enterInitializationMode;
    processMap_["exitInitializationMode"] = &CoSimulationProcessor::process_exitInitializationMode;
    processMap_["terminate"] = &CoSimulationProcessor::process_terminate;
    processMap_["reset"] = &CoSimulationProcessor::process_reset;
    processMap_["freeInstance"] = &CoSimulationProcessor::process_freeInstance;
    processMap_["getReal"] = &CoSimulationProcessor::process_getReal;
    processMap_["getInteger"] = &CoSimulationProcessor::process_getInteger;
    processMap_["getBoolean"] = &CoSimulationProcessor::process_getBoolean;
    processMap_["getString"] = &CoSimulationProcessor::process_getString;
    processMap_["setReal"] = &CoSimulationProcessor::process_setReal;
    processMap_["setInteger"] = &CoSimulationProcessor::process_setInteger;
    processMap_["setBoolean"] = &CoSimulationProcessor::process_setBoolean;
    processMap_["setString"] = &CoSimulationProcessor::process_setString;
    processMap_["setRealInputDerivatives"] = &CoSimulationProcessor::process_setRealInputDerivatives;
    processMap_["setRealOutputDerivatives"] = &CoSimulationProcessor::process_setRealOutputDerivatives;
    processMap_["cancelStep"] = &CoSimulationProcessor::process_cancelStep;
    processMap_["doStep"] = &CoSimulationProcessor::process_doStep;
    processMap_["getStatus"] = &CoSimulationProcessor::process_getStatus;
    processMap_["getIntegerStatus"] = &CoSimulationProcessor::process_getIntegerStatus;
    processMap_["getRealStatus"] = &CoSimulationProcessor::process_getRealStatus;
    processMap_["getBooleanStatus"] = &CoSimulationProcessor::process_getBooleanStatus;
    processMap_["getStringStatus"] = &CoSimulationProcessor::process_getStringStatus;
  }

  virtual ~CoSimulationProcessor() {}
};

class CoSimulationProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  CoSimulationProcessorFactory(const ::boost::shared_ptr< CoSimulationIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< CoSimulationIfFactory > handlerFactory_;
};

class CoSimulationMultiface : virtual public CoSimulationIf {
 public:
  CoSimulationMultiface(std::vector<boost::shared_ptr<CoSimulationIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~CoSimulationMultiface() {}
 protected:
  std::vector<boost::shared_ptr<CoSimulationIf> > ifaces_;
  CoSimulationMultiface() {}
  void add(boost::shared_ptr<CoSimulationIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void getVersion(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getVersion(_return);
    }
    ifaces_[i]->getVersion(_return);
    return;
  }

  void getTypesPlatform(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTypesPlatform(_return);
    }
    ifaces_[i]->getTypesPlatform(_return);
    return;
  }

  void instanciate(Instance& _return, const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->instanciate(_return, instanceName, fmuType, fmuGUID, fmuResourceLocation, visible, loggingOn);
    }
    ifaces_[i]->instanciate(_return, instanceName, fmuType, fmuGUID, fmuResourceLocation, visible, loggingOn);
    return;
  }

  Status::type setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setupExperiment(c, toleranceDefined, tolerance, startTime, stopTimeDefined, stopTime);
    }
    return ifaces_[i]->setupExperiment(c, toleranceDefined, tolerance, startTime, stopTimeDefined, stopTime);
  }

  Status::type enterInitializationMode(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enterInitializationMode(c);
    }
    return ifaces_[i]->enterInitializationMode(c);
  }

  Status::type exitInitializationMode(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exitInitializationMode(c);
    }
    return ifaces_[i]->exitInitializationMode(c);
  }

  Status::type terminate(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->terminate(c);
    }
    return ifaces_[i]->terminate(c);
  }

  Status::type reset(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->reset(c);
    }
    return ifaces_[i]->reset(c);
  }

  void freeInstance(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->freeInstance(c);
    }
    ifaces_[i]->freeInstance(c);
  }

  void getReal(std::vector<double> & _return, const Instance& c, const std::vector<int32_t> & refs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getReal(_return, c, refs);
    }
    ifaces_[i]->getReal(_return, c, refs);
    return;
  }

  void getInteger(std::vector<int32_t> & _return, const Instance& c, const std::vector<int32_t> & refs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getInteger(_return, c, refs);
    }
    ifaces_[i]->getInteger(_return, c, refs);
    return;
  }

  void getBoolean(std::vector<bool> & _return, const Instance& c, const std::vector<int32_t> & refs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getBoolean(_return, c, refs);
    }
    ifaces_[i]->getBoolean(_return, c, refs);
    return;
  }

  void getString(std::vector<std::string> & _return, const Instance& c, const std::vector<int32_t> & refs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getString(_return, c, refs);
    }
    ifaces_[i]->getString(_return, c, refs);
    return;
  }

  Status::type setReal(const Instance& c, const std::map<int32_t, double> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setReal(c, ref_values);
    }
    return ifaces_[i]->setReal(c, ref_values);
  }

  Status::type setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setInteger(c, ref_values);
    }
    return ifaces_[i]->setInteger(c, ref_values);
  }

  Status::type setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setBoolean(c, ref_values);
    }
    return ifaces_[i]->setBoolean(c, ref_values);
  }

  Status::type setString(const Instance& c, const std::map<int32_t, std::string> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setString(c, ref_values);
    }
    return ifaces_[i]->setString(c, ref_values);
  }

  Status::type setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setRealInputDerivatives(c, ref_orders, ref_values);
    }
    return ifaces_[i]->setRealInputDerivatives(c, ref_orders, ref_values);
  }

  Status::type setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setRealOutputDerivatives(c, ref_orders, ref_values);
    }
    return ifaces_[i]->setRealOutputDerivatives(c, ref_orders, ref_values);
  }

  Status::type cancelStep(const Instance& c) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cancelStep(c);
    }
    return ifaces_[i]->cancelStep(c);
  }

  Status::type doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->doStep(c, currentCommunicationPoint, communicationStepSize, noSetFMUStatePriorToCurrentPoint);
    }
    return ifaces_[i]->doStep(c, currentCommunicationPoint, communicationStepSize, noSetFMUStatePriorToCurrentPoint);
  }

  Status::type getStatus(const Instance& c, const StatusKind::type s) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getStatus(c, s);
    }
    return ifaces_[i]->getStatus(c, s);
  }

  int32_t getIntegerStatus(const Instance& c, const StatusKind::type s) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getIntegerStatus(c, s);
    }
    return ifaces_[i]->getIntegerStatus(c, s);
  }

  double getRealStatus(const Instance& c, const StatusKind::type s) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRealStatus(c, s);
    }
    return ifaces_[i]->getRealStatus(c, s);
  }

  bool getBooleanStatus(const Instance& c, const StatusKind::type s) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getBooleanStatus(c, s);
    }
    return ifaces_[i]->getBooleanStatus(c, s);
  }

  void getStringStatus(std::string& _return, const Instance& c, const StatusKind::type s) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getStringStatus(_return, c, s);
    }
    ifaces_[i]->getStringStatus(_return, c, s);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class CoSimulationConcurrentClient : virtual public CoSimulationIf {
 public:
  CoSimulationConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  CoSimulationConcurrentClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getVersion(std::string& _return);
  int32_t send_getVersion();
  void recv_getVersion(std::string& _return, const int32_t seqid);
  void getTypesPlatform(std::string& _return);
  int32_t send_getTypesPlatform();
  void recv_getTypesPlatform(std::string& _return, const int32_t seqid);
  void instanciate(Instance& _return, const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn);
  int32_t send_instanciate(const std::string& instanceName, const Type::type fmuType, const std::string& fmuGUID, const std::string& fmuResourceLocation, const bool visible, const bool loggingOn);
  void recv_instanciate(Instance& _return, const int32_t seqid);
  Status::type setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime);
  int32_t send_setupExperiment(const Instance& c, const bool toleranceDefined, const double tolerance, const double startTime, const bool stopTimeDefined, const double stopTime);
  Status::type recv_setupExperiment(const int32_t seqid);
  Status::type enterInitializationMode(const Instance& c);
  int32_t send_enterInitializationMode(const Instance& c);
  Status::type recv_enterInitializationMode(const int32_t seqid);
  Status::type exitInitializationMode(const Instance& c);
  int32_t send_exitInitializationMode(const Instance& c);
  Status::type recv_exitInitializationMode(const int32_t seqid);
  Status::type terminate(const Instance& c);
  int32_t send_terminate(const Instance& c);
  Status::type recv_terminate(const int32_t seqid);
  Status::type reset(const Instance& c);
  int32_t send_reset(const Instance& c);
  Status::type recv_reset(const int32_t seqid);
  void freeInstance(const Instance& c);
  int32_t send_freeInstance(const Instance& c);
  void recv_freeInstance(const int32_t seqid);
  void getReal(std::vector<double> & _return, const Instance& c, const std::vector<int32_t> & refs);
  int32_t send_getReal(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getReal(std::vector<double> & _return, const int32_t seqid);
  void getInteger(std::vector<int32_t> & _return, const Instance& c, const std::vector<int32_t> & refs);
  int32_t send_getInteger(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getInteger(std::vector<int32_t> & _return, const int32_t seqid);
  void getBoolean(std::vector<bool> & _return, const Instance& c, const std::vector<int32_t> & refs);
  int32_t send_getBoolean(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getBoolean(std::vector<bool> & _return, const int32_t seqid);
  void getString(std::vector<std::string> & _return, const Instance& c, const std::vector<int32_t> & refs);
  int32_t send_getString(const Instance& c, const std::vector<int32_t> & refs);
  void recv_getString(std::vector<std::string> & _return, const int32_t seqid);
  Status::type setReal(const Instance& c, const std::map<int32_t, double> & ref_values);
  int32_t send_setReal(const Instance& c, const std::map<int32_t, double> & ref_values);
  Status::type recv_setReal(const int32_t seqid);
  Status::type setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values);
  int32_t send_setInteger(const Instance& c, const std::map<int32_t, int32_t> & ref_values);
  Status::type recv_setInteger(const int32_t seqid);
  Status::type setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values);
  int32_t send_setBoolean(const Instance& c, const std::map<int32_t, bool> & ref_values);
  Status::type recv_setBoolean(const int32_t seqid);
  Status::type setString(const Instance& c, const std::map<int32_t, std::string> & ref_values);
  int32_t send_setString(const Instance& c, const std::map<int32_t, std::string> & ref_values);
  Status::type recv_setString(const int32_t seqid);
  Status::type setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  int32_t send_setRealInputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  Status::type recv_setRealInputDerivatives(const int32_t seqid);
  Status::type setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  int32_t send_setRealOutputDerivatives(const Instance& c, const std::map<int32_t, int32_t> & ref_orders, const std::map<int32_t, double> & ref_values);
  Status::type recv_setRealOutputDerivatives(const int32_t seqid);
  Status::type cancelStep(const Instance& c);
  int32_t send_cancelStep(const Instance& c);
  Status::type recv_cancelStep(const int32_t seqid);
  Status::type doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint);
  int32_t send_doStep(const Instance& c, const double currentCommunicationPoint, const double communicationStepSize, const bool noSetFMUStatePriorToCurrentPoint);
  Status::type recv_doStep(const int32_t seqid);
  Status::type getStatus(const Instance& c, const StatusKind::type s);
  int32_t send_getStatus(const Instance& c, const StatusKind::type s);
  Status::type recv_getStatus(const int32_t seqid);
  int32_t getIntegerStatus(const Instance& c, const StatusKind::type s);
  int32_t send_getIntegerStatus(const Instance& c, const StatusKind::type s);
  int32_t recv_getIntegerStatus(const int32_t seqid);
  double getRealStatus(const Instance& c, const StatusKind::type s);
  int32_t send_getRealStatus(const Instance& c, const StatusKind::type s);
  double recv_getRealStatus(const int32_t seqid);
  bool getBooleanStatus(const Instance& c, const StatusKind::type s);
  int32_t send_getBooleanStatus(const Instance& c, const StatusKind::type s);
  bool recv_getBooleanStatus(const int32_t seqid);
  void getStringStatus(std::string& _return, const Instance& c, const StatusKind::type s);
  int32_t send_getStringStatus(const Instance& c, const StatusKind::type s);
  void recv_getStringStatus(std::string& _return, const int32_t seqid);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _WIN32
  #pragma warning( pop )
#endif

}}} // namespace

#endif
