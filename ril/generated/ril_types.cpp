/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ril_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace org { namespace raspinloop { namespace fmi {

int _kModelStateValues[] = {
  ModelState::modelStartAndEnd,
  ModelState::modelInstantiated,
  ModelState::modelInitializationMode,
  ModelState::modelEventMode,
  ModelState::modelContinuousTimeMode,
  ModelState::modelStepComplete,
  ModelState::modelStepInProgress,
  ModelState::modelStepFailed,
  ModelState::modelStepCanceled,
  ModelState::modelTerminated,
  ModelState::modelError,
  ModelState::modelFatal
};
const char* _kModelStateNames[] = {
  "modelStartAndEnd",
  "modelInstantiated",
  "modelInitializationMode",
  "modelEventMode",
  "modelContinuousTimeMode",
  "modelStepComplete",
  "modelStepInProgress",
  "modelStepFailed",
  "modelStepCanceled",
  "modelTerminated",
  "modelError",
  "modelFatal"
};
const std::map<int, const char*> _ModelState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kModelStateValues, _kModelStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusValues[] = {
  Status::OK,
  Status::Warning,
  Status::Discard,
  Status::Error,
  Status::Fatal,
  Status::Pending
};
const char* _kStatusNames[] = {
  "OK",
  "Warning",
  "Discard",
  "Error",
  "Fatal",
  "Pending"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTypeValues[] = {
  Type::ModelExchange,
  Type::CoSimulation
};
const char* _kTypeNames[] = {
  "ModelExchange",
  "CoSimulation"
};
const std::map<int, const char*> _Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTypeValues, _kTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusKindValues[] = {
  StatusKind::DoStepStatus,
  StatusKind::PendingStatus,
  StatusKind::LastSuccessfulTime,
  StatusKind::Terminated
};
const char* _kStatusKindNames[] = {
  "DoStepStatus",
  "PendingStatus",
  "LastSuccessfulTime",
  "Terminated"
};
const std::map<int, const char*> _StatusKind_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kStatusKindValues, _kStatusKindNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


EventInfo::~EventInfo() throw() {
}


void EventInfo::__set_newDiscreteStatesNeeded(const bool val) {
  this->newDiscreteStatesNeeded = val;
}

void EventInfo::__set_terminateSimulation(const bool val) {
  this->terminateSimulation = val;
}

void EventInfo::__set_nominalsOfContinuousStatesChanged(const bool val) {
  this->nominalsOfContinuousStatesChanged = val;
}

void EventInfo::__set_valuesOfContinuousStatesChanged(const bool val) {
  this->valuesOfContinuousStatesChanged = val;
}

void EventInfo::__set_nextEventTimeDefined(const bool val) {
  this->nextEventTimeDefined = val;
}

void EventInfo::__set_nextEventTime(const double val) {
  this->nextEventTime = val;
}

uint32_t EventInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->newDiscreteStatesNeeded);
          this->__isset.newDiscreteStatesNeeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->terminateSimulation);
          this->__isset.terminateSimulation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nominalsOfContinuousStatesChanged);
          this->__isset.nominalsOfContinuousStatesChanged = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->valuesOfContinuousStatesChanged);
          this->__isset.valuesOfContinuousStatesChanged = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nextEventTimeDefined);
          this->__isset.nextEventTimeDefined = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->nextEventTime);
          this->__isset.nextEventTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EventInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EventInfo");

  xfer += oprot->writeFieldBegin("newDiscreteStatesNeeded", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->newDiscreteStatesNeeded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("terminateSimulation", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->terminateSimulation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nominalsOfContinuousStatesChanged", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->nominalsOfContinuousStatesChanged);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesOfContinuousStatesChanged", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->valuesOfContinuousStatesChanged);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nextEventTimeDefined", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->nextEventTimeDefined);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nextEventTime", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->nextEventTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EventInfo &a, EventInfo &b) {
  using ::std::swap;
  swap(a.newDiscreteStatesNeeded, b.newDiscreteStatesNeeded);
  swap(a.terminateSimulation, b.terminateSimulation);
  swap(a.nominalsOfContinuousStatesChanged, b.nominalsOfContinuousStatesChanged);
  swap(a.valuesOfContinuousStatesChanged, b.valuesOfContinuousStatesChanged);
  swap(a.nextEventTimeDefined, b.nextEventTimeDefined);
  swap(a.nextEventTime, b.nextEventTime);
  swap(a.__isset, b.__isset);
}

EventInfo::EventInfo(const EventInfo& other0) {
  newDiscreteStatesNeeded = other0.newDiscreteStatesNeeded;
  terminateSimulation = other0.terminateSimulation;
  nominalsOfContinuousStatesChanged = other0.nominalsOfContinuousStatesChanged;
  valuesOfContinuousStatesChanged = other0.valuesOfContinuousStatesChanged;
  nextEventTimeDefined = other0.nextEventTimeDefined;
  nextEventTime = other0.nextEventTime;
  __isset = other0.__isset;
}
EventInfo& EventInfo::operator=(const EventInfo& other1) {
  newDiscreteStatesNeeded = other1.newDiscreteStatesNeeded;
  terminateSimulation = other1.terminateSimulation;
  nominalsOfContinuousStatesChanged = other1.nominalsOfContinuousStatesChanged;
  valuesOfContinuousStatesChanged = other1.valuesOfContinuousStatesChanged;
  nextEventTimeDefined = other1.nextEventTimeDefined;
  nextEventTime = other1.nextEventTime;
  __isset = other1.__isset;
  return *this;
}
void EventInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EventInfo(";
  out << "newDiscreteStatesNeeded=" << to_string(newDiscreteStatesNeeded);
  out << ", " << "terminateSimulation=" << to_string(terminateSimulation);
  out << ", " << "nominalsOfContinuousStatesChanged=" << to_string(nominalsOfContinuousStatesChanged);
  out << ", " << "valuesOfContinuousStatesChanged=" << to_string(valuesOfContinuousStatesChanged);
  out << ", " << "nextEventTimeDefined=" << to_string(nextEventTimeDefined);
  out << ", " << "nextEventTime=" << to_string(nextEventTime);
  out << ")";
}


Instance::~Instance() throw() {
}


void Instance::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

void Instance::__set_componentRef(const int64_t val) {
  this->componentRef = val;
}

void Instance::__set_GUID(const std::string& val) {
  this->GUID = val;
}

void Instance::__set_state(const ModelState::type val) {
  this->state = val;
}

uint32_t Instance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          this->__isset.instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->componentRef);
          this->__isset.componentRef = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->GUID);
          this->__isset.GUID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->state = (ModelState::type)ecast2;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Instance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Instance");

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("componentRef", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->componentRef);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("GUID", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->GUID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Instance &a, Instance &b) {
  using ::std::swap;
  swap(a.instanceName, b.instanceName);
  swap(a.componentRef, b.componentRef);
  swap(a.GUID, b.GUID);
  swap(a.state, b.state);
  swap(a.__isset, b.__isset);
}

Instance::Instance(const Instance& other3) {
  instanceName = other3.instanceName;
  componentRef = other3.componentRef;
  GUID = other3.GUID;
  state = other3.state;
  __isset = other3.__isset;
}
Instance& Instance::operator=(const Instance& other4) {
  instanceName = other4.instanceName;
  componentRef = other4.componentRef;
  GUID = other4.GUID;
  state = other4.state;
  __isset = other4.__isset;
  return *this;
}
void Instance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Instance(";
  out << "instanceName=" << to_string(instanceName);
  out << ", " << "componentRef=" << to_string(componentRef);
  out << ", " << "GUID=" << to_string(GUID);
  out << ", " << "state=" << to_string(state);
  out << ")";
}

}}} // namespace
